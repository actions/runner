// <auto-generated/>
// *** AUTOMATICALLY GENERATED BY GenResourceClass -- DO NOT EDIT!!! ***
using System;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;
using System.Resources;

namespace GitHub.Actions.Expressions {


internal static class ExpressionResources
{


    //********************************************************************************************
    /// Creates the resource manager instance.
    //********************************************************************************************
    static ExpressionResources()
    {
        s_resMgr = new ResourceManager("GitHub.Actions.Expressions.ExpressionResources", typeof(ExpressionResources).GetTypeInfo().Assembly);
    }

    public static ResourceManager Manager
    {
        get
        {
            return s_resMgr;
        }
    }

    //********************************************************************************************
    /// Returns a localized string given a resource string name.
    //********************************************************************************************
    public static String Get(
        String          resourceName)
    {
        return s_resMgr.GetString(resourceName, CultureInfo.CurrentUICulture);
    }

    //********************************************************************************************
    /// Returns a localized integer given a resource string name.
    //********************************************************************************************
    public static int GetInt(
        String          resourceName)
    {
        return (int)s_resMgr.GetObject(resourceName, CultureInfo.CurrentUICulture);
    }

    //********************************************************************************************
    /// Returns a localized string given a resource string name.
    //********************************************************************************************
    public static bool GetBool(
        String          resourceName)
    {
        return (bool)s_resMgr.GetObject(resourceName, CultureInfo.CurrentUICulture);
    }


    //********************************************************************************************
    /// A little helper function to alleviate some typing associated with loading resources and
    /// formatting the strings.  In DEBUG builds, it also asserts that the number of format
    /// arguments and the length of args match.
    //********************************************************************************************
    private static String Format(         // The formatted resource string.
        String          resourceName,     // The name of the resource.
        params Object[] args)             // Arguments to format.
    {
        String resource = Get(resourceName);

#if DEBUG
        // Check to make sure that the number of format string arguments matches the number of
        // arguments passed in.
        int formatArgCount = 0;
        bool[] argSeen = new bool[100];
        for (int i = 0; i < resource.Length; i++)
        {
            if (resource[i] == '{')
            {
                if (i + 1 < resource.Length &&
                    resource[i + 1] == '{')
                {
                    i++;               // Skip the escaped curly braces.
                }
                else
                {
                    // Move past the curly brace and leading whitespace.
                    i++;
                    while (Char.IsWhiteSpace(resource[i]))
                    {
                        i++;
                    }

                    // Get the argument number.
                    int length = 0;
                    while (i + length < resource.Length && Char.IsDigit(resource[i + length]))
                    {
                        length++;
                    }

                    // Record it if it hasn't already been seen.
                    int argNumber = int.Parse(resource.Substring(i, length), CultureInfo.InvariantCulture);
                    if (!argSeen[argNumber])
                    {
                        formatArgCount++;  // Count it as a formatting argument.
                        argSeen[argNumber] = true;
                    }
                }
            }
        }

        Debug.Assert(args != null || formatArgCount == 0, 
                     String.Format(CultureInfo.InvariantCulture, "The number of format arguments is {0}, but the args parameter is null.", formatArgCount));
        Debug.Assert(args == null || formatArgCount == args.Length, 
                     String.Format(CultureInfo.InvariantCulture, "Coding error using resource \"{0}\": The number of format arguments {1} != number of args {2}",
                     resourceName, formatArgCount, args != null ? args.Length : 0));
#endif // DEBUG


        if (args == null)
        {
            return resource;
        }

        // If there are any DateTime structs in the arguments, we need to bracket them 
        // to make sure they are within the supported range of the current calendar.
        for (int i = 0; i < args.Length; i++)
        {
            // DateTime is a struct, we cannot use the as operator and null check.
            if (args[i] is DateTime)
            {
                DateTime dateTime = (DateTime)args[i];

                // We need to fetch the calendar on each Format call since it may change.
                // Since we don't have more than one DateTime for resource, do not
                // bother to cache this for the duration of the for loop.
                Calendar calendar = DateTimeFormatInfo.CurrentInfo.Calendar;
                if (dateTime > calendar.MaxSupportedDateTime)
                {
                    args[i] = calendar.MaxSupportedDateTime;
                }
                else if (dateTime < calendar.MinSupportedDateTime)
                {
                    args[i] = calendar.MinSupportedDateTime;
                }
            }
        }

        return String.Format(CultureInfo.CurrentCulture, resource, args);
    }

    // According to the documentation for the ResourceManager class, it should be sufficient to
    // create a single static instance.  The following is an excerpt from the 1.1 documentation.
    //   Using the methods of ResourceManager, a caller can access the resources for a particular
    //   culture using the GetObject and GetString methods. By default, these methods return the
    //   resource for the culture determined by the current cultural settings of the thread that made
    //   the call.
    private static ResourceManager s_resMgr;

    /// <summary>
    /// The maximum allowed memory size was exceeded while evaluating the following expression: {0}
    /// </summary>
    public static String ExceededAllowedMemory(object arg0) { return Format("ExceededAllowedMemory", arg0); }

    /// <summary>
    /// 0 is replaced with a number.
    ///
    /// Exceeded max expression depth {0}
    /// </summary>
    public static String ExceededMaxExpressionDepth(object arg0) { return Format("ExceededMaxExpressionDepth", arg0); }

    /// <summary>
    /// 0 is replaced with a number.
    ///
    /// Exceeded max expression length {0}
    /// </summary>
    public static String ExceededMaxExpressionLength(object arg0) { return Format("ExceededMaxExpressionLength", arg0); }

    /// <summary>
    /// Expected a property name to follow the dereference operator &apos;.&apos;
    /// </summary>
    public static String ExpectedPropertyName() { return Get("ExpectedPropertyName"); }

    /// <summary>
    /// Expected &apos;(&apos; to follow a function
    /// </summary>
    public static String ExpectedStartParameter() { return Get("ExpectedStartParameter"); }

    /// <summary>
    /// The following format string references more arguments than were supplied: {0}
    /// </summary>
    public static String InvalidFormatArgIndex(object arg0) { return Format("InvalidFormatArgIndex", arg0); }

    /// <summary>
    /// The format specifiers &apos;{0}&apos; are not valid for objects of type &apos;{1}&apos;
    /// </summary>
    public static String InvalidFormatSpecifiers(object arg0, object arg1) { return Format("InvalidFormatSpecifiers", arg0, arg1); }

    /// <summary>
    /// The following format string is invalid: {0}
    /// </summary>
    public static String InvalidFormatString(object arg0) { return Format("InvalidFormatString", arg0); }

    /// <summary>
    /// Key not found &apos;{0}&apos;
    /// </summary>
    public static String KeyNotFound(object arg0) { return Format("KeyNotFound", arg0); }

    /// <summary>
    /// 0 is replaced with the error message
    ///
    /// {0}.
    /// </summary>
    public static String ParseErrorWithFwlink(object arg0) { return Format("ParseErrorWithFwlink", arg0); }

    /// <summary>
    /// 0 is replaced with the parse error message
    /// 1 is replaced with the token
    /// 2 is replaced with the character position within the string
    /// 3 is replaced with the full statement
    ///
    /// {0}: &apos;{1}&apos;. Located at position {2} within expression: {3}.
    /// </summary>
    public static String ParseErrorWithTokenInfo(object arg0, object arg1, object arg2, object arg3) { return Format("ParseErrorWithTokenInfo", arg0, arg1, arg2, arg3); }

    /// <summary>
    /// 0 is replaced with the from-type.
    /// 1 is replaced with the to-type.
    /// 2 is replaced with the value.
    ///
    /// Unable to convert from {0} to {1}. Value: {2}
    /// </summary>
    public static String TypeCastError(object arg0, object arg1, object arg2) { return Format("TypeCastError", arg0, arg1, arg2); }

    /// <summary>
    /// 0 is replaced with the from-type.
    /// 1 is replaced with the to-type.
    ///
    /// Unable to convert from {0} to {1}.
    /// </summary>
    public static String TypeCastErrorNoValue(object arg0, object arg1) { return Format("TypeCastErrorNoValue", arg0, arg1); }

    /// <summary>
    /// 0 is replaced with the from-type.
    /// 1 is replaced with the to-type.
    /// 2 is replaced with the value.
    /// 3 is replaced with the error message.
    ///
    /// Unable to convert from {0} to {1}. Value: {2}. Error: {3}
    /// </summary>
    public static String TypeCastErrorWithError(object arg0, object arg1, object arg2, object arg3) { return Format("TypeCastErrorWithError", arg0, arg1, arg2, arg3); }

    /// <summary>
    /// Unclosed function
    /// </summary>
    public static String UnclosedFunction() { return Get("UnclosedFunction"); }

    /// <summary>
    /// Unclosed indexer
    /// </summary>
    public static String UnclosedIndexer() { return Get("UnclosedIndexer"); }

    /// <summary>
    /// Unexpected symbol
    /// </summary>
    public static String UnexpectedSymbol() { return Get("UnexpectedSymbol"); }

    /// <summary>
    /// Unrecognized value
    /// </summary>
    public static String UnrecognizedValue() { return Get("UnrecognizedValue"); }


}

} // namespace
