// <auto-generated/>
// *** AUTOMATICALLY GENERATED BY GenResourceClass -- DO NOT EDIT!!! ***
using System;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;
using System.Resources;

namespace GitHub.Actions.WorkflowParser {


internal static class WorkflowStrings
{


    //********************************************************************************************
    /// Creates the resource manager instance.
    //********************************************************************************************
    static WorkflowStrings()
    {
        s_resMgr = new ResourceManager("GitHub.Actions.WorkflowParser.WorkflowStrings", typeof(WorkflowStrings).GetTypeInfo().Assembly);
    }

    public static ResourceManager Manager
    {
        get
        {
            return s_resMgr;
        }
    }

    //********************************************************************************************
    /// Returns a localized string given a resource string name.
    //********************************************************************************************
    public static String Get(
        String          resourceName)
    {
        return s_resMgr.GetString(resourceName, CultureInfo.CurrentUICulture);
    }

    //********************************************************************************************
    /// Returns a localized integer given a resource string name.
    //********************************************************************************************
    public static int GetInt(
        String          resourceName)
    {
        return (int)s_resMgr.GetObject(resourceName, CultureInfo.CurrentUICulture);
    }

    //********************************************************************************************
    /// Returns a localized string given a resource string name.
    //********************************************************************************************
    public static bool GetBool(
        String          resourceName)
    {
        return (bool)s_resMgr.GetObject(resourceName, CultureInfo.CurrentUICulture);
    }


    //********************************************************************************************
    /// A little helper function to alleviate some typing associated with loading resources and
    /// formatting the strings.  In DEBUG builds, it also asserts that the number of format
    /// arguments and the length of args match.
    //********************************************************************************************
    private static String Format(         // The formatted resource string.
        String          resourceName,     // The name of the resource.
        params Object[] args)             // Arguments to format.
    {
        String resource = Get(resourceName);

#if DEBUG
        // Check to make sure that the number of format string arguments matches the number of
        // arguments passed in.
        int formatArgCount = 0;
        bool[] argSeen = new bool[100];
        for (int i = 0; i < resource.Length; i++)
        {
            if (resource[i] == '{')
            {
                if (i + 1 < resource.Length &&
                    resource[i + 1] == '{')
                {
                    i++;               // Skip the escaped curly braces.
                }
                else
                {
                    // Move past the curly brace and leading whitespace.
                    i++;
                    while (Char.IsWhiteSpace(resource[i]))
                    {
                        i++;
                    }

                    // Get the argument number.
                    int length = 0;
                    while (i + length < resource.Length && Char.IsDigit(resource[i + length]))
                    {
                        length++;
                    }

                    // Record it if it hasn't already been seen.
                    int argNumber = int.Parse(resource.Substring(i, length), CultureInfo.InvariantCulture);
                    if (!argSeen[argNumber])
                    {
                        formatArgCount++;  // Count it as a formatting argument.
                        argSeen[argNumber] = true;
                    }
                }
            }
        }

        Debug.Assert(args != null || formatArgCount == 0, 
                     String.Format(CultureInfo.InvariantCulture, "The number of format arguments is {0}, but the args parameter is null.", formatArgCount));
        Debug.Assert(args == null || formatArgCount == args.Length, 
                     String.Format(CultureInfo.InvariantCulture, "Coding error using resource \"{0}\": The number of format arguments {1} != number of args {2}",
                     resourceName, formatArgCount, args != null ? args.Length : 0));
#endif // DEBUG


        if (args == null)
        {
            return resource;
        }

        // If there are any DateTime structs in the arguments, we need to bracket them 
        // to make sure they are within the supported range of the current calendar.
        for (int i = 0; i < args.Length; i++)
        {
            // DateTime is a struct, we cannot use the as operator and null check.
            if (args[i] is DateTime)
            {
                DateTime dateTime = (DateTime)args[i];

                // We need to fetch the calendar on each Format call since it may change.
                // Since we don't have more than one DateTime for resource, do not
                // bother to cache this for the duration of the for loop.
                Calendar calendar = DateTimeFormatInfo.CurrentInfo.Calendar;
                if (dateTime > calendar.MaxSupportedDateTime)
                {
                    args[i] = calendar.MaxSupportedDateTime;
                }
                else if (dateTime < calendar.MinSupportedDateTime)
                {
                    args[i] = calendar.MinSupportedDateTime;
                }
            }
        }

        return String.Format(CultureInfo.CurrentCulture, resource, args);
    }

    // According to the documentation for the ResourceManager class, it should be sufficient to
    // create a single static instance.  The following is an excerpt from the 1.1 documentation.
    //   Using the methods of ResourceManager, a caller can access the resources for a particular
    //   culture using the GetObject and GetString methods. By default, these methods return the
    //   resource for the culture determined by the current cultural settings of the thread that made
    //   the call.
    private static ResourceManager s_resMgr;

    /// <summary>
    /// The workflow is not valid.
    /// </summary>
    public static String WorkflowNotValid() { return Get("WorkflowNotValid"); }

    /// <summary>
    /// The workflow is not valid. {0}
    /// </summary>
    public static String WorkflowNotValidWithErrors(object arg0) { return Format("WorkflowNotValidWithErrors", arg0); }
}

} // namespace
