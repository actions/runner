// <auto-generated/>
// *** AUTOMATICALLY GENERATED BY GenResourceClass -- DO NOT EDIT!!! ***
using System;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;
using System.Resources;

namespace GitHub.Actions.WorkflowParser.ObjectTemplating {


internal static class TemplateStrings
{


    //********************************************************************************************
    /// Creates the resource manager instance.
    //********************************************************************************************
    static TemplateStrings()
    {
        s_resMgr = new ResourceManager("GitHub.Actions.WorkflowParser.ObjectTemplating.TemplateStrings", typeof(TemplateStrings).GetTypeInfo().Assembly);
    }

    public static ResourceManager Manager
    {
        get
        {
            return s_resMgr;
        }
    }

    //********************************************************************************************
    /// Returns a localized string given a resource string name.
    //********************************************************************************************
    public static String Get(
        String          resourceName)
    {
        return s_resMgr.GetString(resourceName, CultureInfo.CurrentUICulture);
    }

    //********************************************************************************************
    /// Returns a localized integer given a resource string name.
    //********************************************************************************************
    public static int GetInt(
        String          resourceName)
    {
        return (int)s_resMgr.GetObject(resourceName, CultureInfo.CurrentUICulture);
    }

    //********************************************************************************************
    /// Returns a localized string given a resource string name.
    //********************************************************************************************
    public static bool GetBool(
        String          resourceName)
    {
        return (bool)s_resMgr.GetObject(resourceName, CultureInfo.CurrentUICulture);
    }


    //********************************************************************************************
    /// A little helper function to alleviate some typing associated with loading resources and
    /// formatting the strings.  In DEBUG builds, it also asserts that the number of format
    /// arguments and the length of args match.
    //********************************************************************************************
    private static String Format(         // The formatted resource string.
        String          resourceName,     // The name of the resource.
        params Object[] args)             // Arguments to format.
    {
        String resource = Get(resourceName);

#if DEBUG
        // Check to make sure that the number of format string arguments matches the number of
        // arguments passed in.
        int formatArgCount = 0;
        bool[] argSeen = new bool[100];
        for (int i = 0; i < resource.Length; i++)
        {
            if (resource[i] == '{')
            {
                if (i + 1 < resource.Length &&
                    resource[i + 1] == '{')
                {
                    i++;               // Skip the escaped curly braces.
                }
                else
                {
                    // Move past the curly brace and leading whitespace.
                    i++;
                    while (Char.IsWhiteSpace(resource[i]))
                    {
                        i++;
                    }

                    // Get the argument number.
                    int length = 0;
                    while (i + length < resource.Length && Char.IsDigit(resource[i + length]))
                    {
                        length++;
                    }

                    // Record it if it hasn't already been seen.
                    int argNumber = int.Parse(resource.Substring(i, length), CultureInfo.InvariantCulture);
                    if (!argSeen[argNumber])
                    {
                        formatArgCount++;  // Count it as a formatting argument.
                        argSeen[argNumber] = true;
                    }
                }
            }
        }

        Debug.Assert(args != null || formatArgCount == 0, 
                     String.Format(CultureInfo.InvariantCulture, "The number of format arguments is {0}, but the args parameter is null.", formatArgCount));
        Debug.Assert(args == null || formatArgCount == args.Length, 
                     String.Format(CultureInfo.InvariantCulture, "Coding error using resource \"{0}\": The number of format arguments {1} != number of args {2}",
                     resourceName, formatArgCount, args != null ? args.Length : 0));
#endif // DEBUG


        if (args == null)
        {
            return resource;
        }

        // If there are any DateTime structs in the arguments, we need to bracket them 
        // to make sure they are within the supported range of the current calendar.
        for (int i = 0; i < args.Length; i++)
        {
            // DateTime is a struct, we cannot use the as operator and null check.
            if (args[i] is DateTime)
            {
                DateTime dateTime = (DateTime)args[i];

                // We need to fetch the calendar on each Format call since it may change.
                // Since we don't have more than one DateTime for resource, do not
                // bother to cache this for the duration of the for loop.
                Calendar calendar = DateTimeFormatInfo.CurrentInfo.Calendar;
                if (dateTime > calendar.MaxSupportedDateTime)
                {
                    args[i] = calendar.MaxSupportedDateTime;
                }
                else if (dateTime < calendar.MinSupportedDateTime)
                {
                    args[i] = calendar.MinSupportedDateTime;
                }
            }
        }

        return String.Format(CultureInfo.CurrentCulture, resource, args);
    }

    // According to the documentation for the ResourceManager class, it should be sufficient to
    // create a single static instance.  The following is an excerpt from the 1.1 documentation.
    //   Using the methods of ResourceManager, a caller can access the resources for a particular
    //   culture using the GetObject and GetString methods. By default, these methods return the
    //   resource for the culture determined by the current cultural settings of the thread that made
    //   the call.
    private static ResourceManager s_resMgr;

    /// <summary>
    /// The expression directive &apos;{0}&apos; is not supported in this context
    /// </summary>
    public static String DirectiveNotAllowed(object arg0) { return Format("DirectiveNotAllowed", arg0); }

    /// <summary>
    /// The directive &apos;{0}&apos; is not allowed in this context. Directives are not supported for expressions that are embedded within a string. Directives are only supported when the entire value is an expression.
    /// </summary>
    public static String DirectiveNotAllowedInline(object arg0) { return Format("DirectiveNotAllowedInline", arg0); }

    /// <summary>
    /// An expression was expected
    /// </summary>
    public static String ExpectedExpression() { return Get("ExpectedExpression"); }

    /// <summary>
    /// Expected a mapping
    /// </summary>
    public static String ExpectedMapping() { return Get("ExpectedMapping"); }

    /// <summary>
    /// Exactly {0} parameter(s) were expected following the directive &apos;{1}&apos;. Actual parameter count: {2}
    /// </summary>
    public static String ExpectedNParametersFollowingDirective(object arg0, object arg1, object arg2) { return Format("ExpectedNParametersFollowingDirective", arg0, arg1, arg2); }

    /// <summary>
    /// Expected a scalar value
    /// </summary>
    public static String ExpectedScalar() { return Get("ExpectedScalar"); }

    /// <summary>
    /// Expected a scalar value, a sequence, or a mapping
    /// </summary>
    public static String ExpectedScalarSequenceOrMapping() { return Get("ExpectedScalarSequenceOrMapping"); }

    /// <summary>
    /// Expected a sequence
    /// </summary>
    public static String ExpectedSequence() { return Get("ExpectedSequence"); }

    /// <summary>
    /// A template expression is not allowed in this context
    /// </summary>
    public static String ExpressionNotAllowed() { return Get("ExpressionNotAllowed"); }

    /// <summary>
    /// The expression is not closed. An unescaped ${{ sequence was found, but the closing }} sequence was not found.
    /// </summary>
    public static String ExpressionNotClosed() { return Get("ExpressionNotClosed"); }

    /// <summary>
    /// Error message prefix that indicates the line and column where the error occurred
    ///
    /// (Line: {0}, Col: {1})
    /// </summary>
    public static String LineColumn(object arg0, object arg1) { return Format("LineColumn", arg0, arg1); }

    /// <summary>
    /// Maximum object depth exceeded
    /// </summary>
    public static String MaxObjectDepthExceeded() { return Get("MaxObjectDepthExceeded"); }

    /// <summary>
    /// Maximum object size exceeded
    /// </summary>
    public static String MaxObjectSizeExceeded() { return Get("MaxObjectSizeExceeded"); }

    /// <summary>
    /// Maximum events exceeded while evaluating the template. This may indicate an infinite loop or too many nested loops.
    /// </summary>
    public static String MaxTemplateEventsExceeded() { return Get("MaxTemplateEventsExceeded"); }

    /// <summary>
    /// The template is not valid.
    /// </summary>
    public static String TemplateNotValid() { return Get("TemplateNotValid"); }

    /// <summary>
    /// The template is not valid. {0}
    /// </summary>
    public static String TemplateNotValidWithErrors(object arg0) { return Format("TemplateNotValidWithErrors", arg0); }

    /// <summary>
    /// In {0} {1}: Error from called workflow
    /// </summary>
    public static String CalledWorkflowNotValidWithErrors(object arg0, object arg1) { return Format("CalledWorkflowNotValidWithErrors", arg0, arg1); }

    /// <summary>
    /// Unable to convert the object to a template token. Actual type &apos;{0}&apos;
    /// </summary>
    public static String UnableToConvertToTemplateToken(object arg0) { return Format("UnableToConvertToTemplateToken", arg0); }

    /// <summary>
    /// There&apos;s not enough info to determine what you meant. Add one of these properties: {0}
    /// </summary>
    public static String UnableToDetermineOneOf(object arg0) { return Format("UnableToDetermineOneOf", arg0); }

    /// <summary>
    /// A mapping was not expected
    /// </summary>
    public static String UnexpectedMappingStart() { return Get("UnexpectedMappingStart"); }

    /// <summary>
    /// A sequence was not expected
    /// </summary>
    public static String UnexpectedSequenceStart() { return Get("UnexpectedSequenceStart"); }

    /// <summary>
    /// Unexpected value &apos;{0}&apos;
    /// </summary>
    public static String UnexpectedValue(object arg0) { return Format("UnexpectedValue", arg0); }

    /// <summary>
    /// &apos;{0}&apos; is already defined
    /// </summary>
    public static String ValueAlreadyDefined(object arg0) { return Format("ValueAlreadyDefined", arg0); }


}

} // namespace
