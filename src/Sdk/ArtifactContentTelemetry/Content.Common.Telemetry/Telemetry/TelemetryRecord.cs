using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using GitHub.Services.Common;
using GitHub.Services.WebApi;

namespace GitHub.Services.Content.Common.Telemetry
{
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1401:FieldsMustBePrivate", Justification = "Protected fields are fine thanks")]
    public class TelemetryRecord
    {
        static TelemetryRecord()
        {
            try
            {
                CurrentOSName = TelemetryPlatformSpecific.OSName;
                CurrentOSVersion = TelemetryPlatformSpecific.OSVersion;
                CurrentFrameworkDescription = TelemetryPlatformSpecific.FrameworkDescription;
            }
            catch { }

            // The version of the assembly containing TelemetryRecord will match that of drop.exe and symbol.exe for a given release
            var versionInfo = FileVersionInfo.GetVersionInfo(typeof(TelemetryRecord).Assembly.Location);
            CurrentVersion = versionInfo.FileVersion; // e.g. 15.119.26619.25 built by: releases/M119 (2051611c84)

            ReadUserDomainEnvironmentVariables();
        }

        internal static void ReadUserDomainEnvironmentVariables()
        {
            CurrentUserDomain = Environment.GetEnvironmentVariable("USERDOMAIN");
            CurrentUserDnsDomain = Environment.GetEnvironmentVariable("USERDNSDOMAIN");
        }

        private static readonly string ComputerName = Environment.GetEnvironmentVariable("COMPUTERNAME");
        private static readonly string CurrentOSName;
        private static readonly string CurrentOSVersion;
        private static readonly string CurrentProcessName = Process.GetCurrentProcess().ProcessName;
        private static string CurrentUserDomain;
        private static string CurrentUserDnsDomain;
        private static readonly string CurrentUserName = Environment.GetEnvironmentVariable("USERNAME");
        private static readonly string CurrentVersion;
        private static readonly string CurrentFrameworkDescription;

        // More build and release variables are available, but the collection and IDs below are sufficient to measure customer impact and correlate to this information if needed.
        // https://www.visualstudio.com/en-us/docs/build/define/variables#predefined-variables
        // https://www.visualstudio.com/en-us/docs/build/concepts/definitions/release/variables#default-variables
        private static readonly string Current_SYSTEM_TEAMFOUNDATIONCOLLECTIONURI = Environment.GetEnvironmentVariable("SYSTEM_TEAMFOUNDATIONCOLLECTIONURI");
        private static readonly string Current_SYSTEM_COLLECTIONID = Environment.GetEnvironmentVariable("SYSTEM_COLLECTIONID");
        private static readonly string Current_SYSTEM_PROJECTID = Environment.GetEnvironmentVariable("SYSTEM_TEAMPROJECTID");
        private static readonly string Current_SYSTEM_HOSTTYPE = Environment.GetEnvironmentVariable("SYSTEM_HOSTTYPE");
        private static readonly string Current_BUILD_BUILDID = Environment.GetEnvironmentVariable("BUILD_BUILDID");
        private static readonly string Current_RELEASE_RELEASEID = Environment.GetEnvironmentVariable("RELEASE_RELEASEID");

        /// <summary>
        /// This value persists for the lifetime of the process or until VssClientHttpRequestSettings.ResetDefaultSettings() is called.
        /// In the code, it is generated by GitHub.Services.Common.VssHttpRequestSettings().
        /// On the wire, it is sent in a header, X-TFS-Session, which is defined at GitHub.Services.Common.Internal.HttpHeaders.TfsSessionHeader.
        /// In Kusto IisLogs, it is written to X_TFS_Session.
        /// </summary>
        public static Guid Current_X_TFS_Session => VssClientHttpRequestSettings.Default.SessionId;

        protected internal Uri baseAddress;

        public TelemetryRecord(TelemetryInformationLevel level, Uri clientBaseAddress)
        {
            ArgumentUtility.CheckForNull(clientBaseAddress, nameof(clientBaseAddress));

            // Record created time
            this.CreatedUtcNow = DateTime.UtcNow.ToString("o");

            // Detail level to include in the record
            this.Level = level;

            // VSTS service address and properties based on it
            this.baseAddress = clientBaseAddress;
            this.BaseAddress = clientBaseAddress.ToString();
            this.DeploymentEnvironment = GetDeploymentEnvironment(this.baseAddress);
            this.DeploymentEnvironmentIsProduction = this.DeploymentEnvironment == Production;
            this.VSOAccount = GetAccountName(this.baseAddress);
            this.X_TFS_Session = Current_X_TFS_Session;

            // Assembly-wide
            this.Version = CurrentVersion;

            // Process-wide
            this.ProcessName = CurrentProcessName;
            this.UserDomain = OmitPerCompliance(CurrentUserDomain);
            this.UserName = OmitPerCompliance(CurrentUserName);

            // Machine-wide
            this.ClientComputerName = OmitPerCompliance(ComputerName);
            this.OSName = CurrentOSName;
            this.OSVersion = CurrentOSVersion;
            this.FrameworkDescription = CurrentFrameworkDescription;

            // TeamBuild
            if (this.Level >= TelemetryInformationLevel.FirstParty)
            {
                this.SYSTEM_TEAMFOUNDATIONCOLLECTIONURI = Current_SYSTEM_TEAMFOUNDATIONCOLLECTIONURI;
                this.SYSTEM_COLLECTIONID = Current_SYSTEM_COLLECTIONID;
                this.SYSTEM_PROJECTID = Current_SYSTEM_PROJECTID;
                this.SYSTEM_HOSTTYPE = Current_SYSTEM_HOSTTYPE;
                this.BUILD_BUILDID = Current_BUILD_BUILDID;
                this.RELEASE_RELEASEID = Current_RELEASE_RELEASEID;
            }

            this.DotNetReleaseDword = TelemetryPlatformSpecific.DotNetReleaseDword;
        }

        /// <summary>
        /// Copy constructor for derived classes
        /// </summary>
        protected TelemetryRecord(TelemetryRecord record) : this(record.Level, record.baseAddress)
        {
            this.Exception = record.exception;
            this.CorrelationId = record.CorrelationId;
            this.X_TFS_Session = record.X_TFS_Session;
            this.ClientComputerName = record.ClientComputerName;
            this.OSName = record.OSName;
            this.OSVersion = record.OSVersion;
            this.FrameworkDescription = record.FrameworkDescription;
            this.DeploymentEnvironment = record.DeploymentEnvironment;
            this.DeploymentEnvironmentIsProduction = record.DeploymentEnvironmentIsProduction;
            this.VSOAccount = record.VSOAccount;
            this.ProcessName = record.ProcessName;
            this.UserDomain = record.UserDomain;
            this.UserName = record.UserName;
            this.Exception = record.Exception;
            this.SYSTEM_TEAMFOUNDATIONCOLLECTIONURI = record.SYSTEM_TEAMFOUNDATIONCOLLECTIONURI;
            this.SYSTEM_COLLECTIONID = record.SYSTEM_COLLECTIONID;
            this.SYSTEM_PROJECTID = record.SYSTEM_PROJECTID;
            this.SYSTEM_HOSTTYPE = record.SYSTEM_HOSTTYPE;
            this.BUILD_BUILDID = record.BUILD_BUILDID;
            this.RELEASE_RELEASEID = record.RELEASE_RELEASEID;
            this.DotNetReleaseDword = record.DotNetReleaseDword;
        }

        #region TelemetryInformationLevel
        internal const string OmittedTelemetryValue = "OMITTED";

        internal const string FirstPartyOmittedDomain = "EUROPE";
        private const string FirstPartyOmittedDnsDomain = "europe.corp.microsoft.com";

        public TelemetryInformationLevel Level { get; }

        public string OmitPerCompliance(string value)
        {
            if (this.Level >= TelemetryInformationLevel.FirstParty
                && !string.Equals(CurrentUserDomain, FirstPartyOmittedDomain, StringComparison.OrdinalIgnoreCase)
                && !string.Equals(CurrentUserDnsDomain, FirstPartyOmittedDnsDomain, StringComparison.OrdinalIgnoreCase))
            {
                return value;
            }
            else
            {
                return OmittedTelemetryValue;
            }
        }
        #endregion

        /// <summary>
        /// Time at which the record's constructor was called.
        /// </summary>
        public string CreatedUtcNow { get; }

        /// <summary>
        /// Approximate time at which the sender attempted to store/transmit the record.
        /// </summary>
        public string SentUtcNow { get; internal set; }

        public string BaseAddress { get; }

        /// <summary>
        /// An ID provided by the caller which represents a client-defined session of activity.
        /// </summary>
        public Guid CorrelationId { get; set; }

        /// <summary>
        /// This value persists for the lifetime of the process or until VssClientHttpRequestSettings.ResetDefaultSettings() is called.
        /// In the code, it is generated by GitHub.Services.Common.VssHttpRequestSettings().
        /// On the wire, it is sent in a header, X-TFS-Session, which is defined at GitHub.Services.Common.Internal.HttpHeaders.TfsSessionHeader.
        /// In Kusto IisLogs, it is written to X_TFS_Session.
        /// </summary>
        public Guid X_TFS_Session { get; set; }

        public string ClientComputerName { get; }

        public string DeploymentEnvironment { get; }

        public bool DeploymentEnvironmentIsProduction { get; }

        public string VSOAccount { get; }

        public string OSName { get; }
        public string OSVersion { get; }
        public string FrameworkDescription { get; }

        public string ProcessName { get; }

        public string UserName { get; }
        public string UserDomain { get; }

        /// <summary>
        /// Use this link to determine the .NET version number to release DWORD
        /// https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed
        /// </summary>
        public int DotNetReleaseDword { get; }

        [Obsolete("Please use the VSOAccount property to obtain this value")]
        public string GetServiceHost(bool vsoAccountOnly)
        {
            return this.VSOAccount;
        }

        /// <summary>
        /// Strips null, OMITTED, and empty guids from a TelemetryRecord
        /// </summary>
        /// <returns>All non-default properties and their values</returns>
        public Dictionary<string, string> GetAssignedProperties()
        {
            var result = new Dictionary<string, string>();
                foreach (var prop in this.GetType().GetProperties())
                {
                    var value = prop.GetValue(this);
                    if (value != null && !string.Equals(value, OmittedTelemetryValue) && !string.Equals(value, Guid.Empty))
                    {
                        // Non-empty properties
                        result.Add(prop.Name, value.ToString());
                    }
                }
            return result;
        }
        private const string Production = "PRODUCTION";

        internal static string GetDeploymentEnvironment(Uri baseAddress)
        {
            String environment = "UNKNOWN";
            String targetAddress = baseAddress.AbsoluteUri.ToUpperInvariant();
            if (targetAddress.Contains(("//" + Environment.GetEnvironmentVariable("COMPUTERNAME") + ":").ToUpperInvariant()) ||
                targetAddress.Contains(("//localhost").ToUpperInvariant()))
            {
                environment = "SIMULATOR";
            }
            else if (targetAddress.Contains("tfsallin.net:16080".ToUpperInvariant()) ||
                     targetAddress.Contains("tfsallin.net:16443".ToUpperInvariant()) ||
                     targetAddress.Contains("codedev.ms".ToUpperInvariant()))
            {
                environment = "DEVFABRIC";
            }
            else if (targetAddress.Contains("codeapp.ms".ToUpperInvariant()))
            {
                environment = "APPFABRIC";
            }
            else if (targetAddress.Contains(".visualstudio.com".ToUpperInvariant()) ||
                     targetAddress.Contains("dev.azure.com".ToUpperInvariant()))
            {
                environment = Production;
            }
            else if (targetAddress.Contains(".vsallin.net".ToUpperInvariant())
                || targetAddress.Contains("codexppe.azure.com".ToUpperInvariant()))
            {
                environment = "PPE";
            }

            return environment;
        }

        internal static string GetAccountName(Uri baseAddress)
        {
            string organizationName = null;

            // New format per https://mseng.visualstudio.com/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FStandards%2C%20Practices%20and%20Tools%2FFundamental%20Tools%20and%20Infrastructure%2FFrameworks%20and%20Libraries%2FVisual%20Studio%20Services%20Framework%2FVSTS%20Domain%20Changes&wikiVersion=GBwikiMaster
            if (
                baseAddress.Host.EndsWith("azure.com", StringComparison.OrdinalIgnoreCase) ||
                baseAddress.Host.EndsWith(".ms", StringComparison.OrdinalIgnoreCase))
            {
                // New format example: https://dev.azure.com/mseng
                var path = baseAddress.GetComponents(UriComponents.Path, UriFormat.SafeUnescaped);
                if (!string.IsNullOrEmpty(path))
                {
                    organizationName = path.Split('/')[0];
                }
            }
            else
            {
                // Old format example: https://mseng.visualstudio.com
                organizationName = baseAddress
                    .GetComponents(UriComponents.Host, UriFormat.SafeUnescaped) // domain name e.g. artifactsu0.artifacts.visualstudio.com
                    .Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries)[0]; // first "label" of the domain name e.g. artifactsu0
            }

            return organizationName;
        }

        public string Version { get; }

        #region Exception
        private Exception exception = null;
        private const int MaxExceptionDetailLength = 5 * 1024;

        public int ExceptionCount { get; private set; }
        public string ExceptionDetail { get; private set; }
        public string ExceptionMessage { get; private set; }
        public string ExceptionType { get; private set; }
        public string ExceptionStack { get; private set; }

        public Exception Exception
        {
            get
            {
                return exception;
            }

            protected set
            {
                exception = value;
                ProcessException();
            }
        }

        private void ProcessException()
        {
            if (this.Exception == null)
            {
                return;
            }

            var aggEx = this.Exception as AggregateException;
            if (aggEx == null)
            {
                this.ExceptionCount = 1;
                this.ExceptionDetail = this.Exception.ToString(); // Exception.ToString() includes all nested InnerExceptions
                this.ExceptionMessage = this.Exception.Message;
                this.ExceptionStack = this.Exception.StackTrace;
                this.ExceptionType = this.Exception.GetType().Name;
            }
            else
            {
                // Unwrap aggregate exception

                this.ExceptionCount = aggEx.InnerExceptions.Count;

                var summary = new StringBuilder("AggregateException InnerExceptions\r\n");
                var exceptionStrings = aggEx.InnerExceptions.Select(e => e.ToString()).OrderBy(s => s).ToArray();
                for (int i = 0; i < exceptionStrings.Length; i++)
                {
                    summary.AppendFormat("{0}. {1}", (i + 1), exceptionStrings[i]);
                    if (i < exceptionStrings.Length - 1)
                    {
                        summary.Append("\r\n(NextException)\r\n");
                    }
                }

                this.ExceptionDetail = TruncateToLength(summary.ToString(), MaxExceptionDetailLength);
                this.ExceptionMessage = GetDistinctValueOrMultiple(aggEx.InnerExceptions.Select(e => e.Message));
                this.ExceptionType = GetDistinctValueOrMultiple(aggEx.InnerExceptions.Select(e => e.GetType().Name));
                this.ExceptionStack = GetDistinctValueOrMultiple(aggEx.InnerExceptions.Select(e => e.StackTrace));
            }
        }

        private string GetDistinctValueOrMultiple(IEnumerable<string> values)
        {
            var distinctValues = values.Distinct(StringComparer.OrdinalIgnoreCase).ToArray();
            return distinctValues.Length == 1 ? distinctValues.Single() : "Multiple";
        }

        private string TruncateToLength(string value, int maxLength)
        {
            if (value == null || value.Length <= maxLength)
            {
                return value;
            }
            else
            {
                return value.Substring(0, maxLength);
            }
        }
        #endregion

        #region Team Build
        public string SYSTEM_TEAMFOUNDATIONCOLLECTIONURI { get; }
        public string SYSTEM_COLLECTIONID { get; }
        public string SYSTEM_PROJECTID { get; }
        public string SYSTEM_HOSTTYPE { get; }
        public string BUILD_BUILDID { get; }
        public string RELEASE_RELEASEID { get; }
        #endregion
    }
}
